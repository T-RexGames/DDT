<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create the level
var xTemp = 0;
var yTemp = 0;
// Resize the room
room_width = (CELL_WIDTH/16) * 1000;
room_height = (CELL_HEIGHT/16) * 1000;

// Set the grid width and height
var width = room_width div CELL_WIDTH;
var height = room_height div CELL_HEIGHT;

// Create the grid
grid = ds_grid_create(width, height);

//create the pathfinding grid
grid_path = mp_grid_create(0, 0, width, height, CELL_WIDTH, CELL_HEIGHT);

// Fill the grid with the void
ds_grid_set_region(grid, 0, 0, width-1, height-1, VOID);

// Randomize the world
randomize();

// Create the controller in the center of the grid
var cx = width div 2;
var cy = height div 2;


//create the healthbar




// Give the controller a random direction
var cdir = irandom(3);

// The odds variable for chaning direction
var odds = 6;

// Create the level using 1000 steps
var reachedNorth = false;
var reachedSouth = false;
var reachedEast = false;
var reachedWest = false;
var north = 0;
var south = 2;
var east = 1;
var west = 3;

repeat (2500) {
    // Place a floor tile at the controller position
    grid[# cx, cy] = FLOOR;
    
    if(irandom(20)==2){
     grid[# cx, cy] = ICE;
    }
 
    // Randomize the direction of the controller
    
     if (reachedNorth) { north = choose(1,2,3)}
    if (reachedEast ) { east = choose(0,2,3)};
    if (reachedSouth) { south = choose(0,1,3)};
    if (reachedWest ) { west = choose(0,1,2)};
    
    if (irandom(odds) == odds) {
        cdir = choose(north, south, east, west);
    }
    
    // Move the controller
    var xdir = lengthdir_x(1, cdir*90);
    var ydir = lengthdir_y(1, cdir*90);
    cx += xdir;
    cy += ydir;
    
    // Make sure we don't move outside the grid
    cx = clamp(cx, 1, width-2);
    cy = clamp(cy, 1, height-2);
    
       //Track that we have reached any of the 4 walls
    if (cy == height -2) {reachedNorth = true;}
    if (cy == 1 ){reachedSouth = true};
    if (cx == width - 2) {reachedEast = true};
    if (cx == 1 ){reachedWest = true};
}

// Add the walls
for (var yy = 1; yy &lt; height-1; yy++) {
    for (var xx = 1; xx &lt; width-1; xx++) {
        if (grid[# xx, yy] == FLOOR || grid[# xx, yy] == ICE) {
            // Check for walls
            if (grid[# xx+1, yy] != FLOOR &amp;&amp; grid[# xx+1, yy] != ICE) grid[# xx+1, yy] = WALL;
            if (grid[# xx-1, yy] != FLOOR &amp;&amp; grid[# xx-1, yy] != ICE) grid[# xx-1, yy] = WALL;
            if (grid[# xx, yy+1] != FLOOR &amp;&amp; grid[# xx, yy+1] != ICE) grid[# xx, yy+1] = WALL;
            if (grid[# xx, yy-1] != FLOOR &amp;&amp; grid[# xx, yy-1] != ICE) grid[# xx, yy-1] = WALL;
        }
    }
}

var cabinPlaced = false;
var timPlaced = false;


// Draw the floor tiles
for (var yy = 0; yy &lt; height; yy++) {
    for (var xx = 0; xx &lt; width; xx++) {
        if (grid[# xx, yy] == FLOOR) {
            // Draw the floor
            tile_add(bg_floor, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 0);

            //Place Cabin 
            if (!cabinPlaced){
                if (irandom(20) == 1) {
                    tile_add(bg_Cabin, 0, 0, CELL_WIDTH*2, CELL_HEIGHT*2, xx*CELL_WIDTH, yy*CELL_HEIGHT, -10);
                    instance_create(xx*CELL_WIDTH+15, yy*CELL_HEIGHT+15, obj_Player); 
                    cabinPlaced = true;
                 }
            }
            
            if(cabinPlaced &amp;&amp; !timPlaced){
                if( 
                     (point_distance(obj_Player.x, obj_Player.y, xx*CELL_WIDTH, yy*CELL_HEIGHT) &gt; 1500)
                     &amp;&amp;
                     ((yy*CELL_HEIGHT - obj_Player.y) &gt; 800)
                   ){
                    //tile_add(bg_Tims, 0, 0, CELL_WIDTH*2, CELL_HEIGHT*2, xx*CELL_WIDTH, yy*CELL_HEIGHT, -10);
                    instance_create(xx*CELL_WIDTH, yy*CELL_HEIGHT, obj_tims);
                    timPlaced = true;
                }
            }
        
          }
        else if(grid[# xx, yy] == ICE){
        //show_debug_message("ICE");
            tile_add(bg_ice, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, -5);
           
        }
      else {
        mp_grid_add_cell(grid_path, xx, yy);
        
      }
    }
}

// Draw the wall tiles.
for (var yy = 0; yy &lt; height; yy++) {
    for (var xx = 0; xx &lt; width; xx++) {
        if (grid[# xx, yy] == WALL) {
            // Draw the floor
           // if (irandom(odds) == odds) {
                tile_add(bg_floor, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 0)
                tile_add(bg_TwoTrees, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 0)
          //  }
        }
    }
}

//Draw the void tiles
for (var yy = 0; yy &lt; height; yy++) {
    for (var xx = 0; xx &lt; width; xx++) {
        if ((grid[# xx, yy] != WALL) &amp;&amp; (grid[# xx, yy] != FLOOR)) {
             //Draw the floor
                tile_add(bg_floor, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 0)
                tile_add(bg_TwoTrees, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 0)
                  //if (irandom(odds) == odds) {
               
            //}
        }
    }
}

////////////////////////////////////////////
//Place features here.








//instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, obj_Player); 

var mooseplaced = false;
//Place Snowmen.
for (var yy = 0; yy &lt; height; yy++) {
    for (var xx = 0; xx &lt; width; xx++) {
        if ((grid[# xx, yy] != WALL) &amp;&amp; (grid[# xx, yy] == FLOOR)) {
       
            //add some snowmen
            var odds = 40;
            var ex = xx*CELL_WIDTH+CELL_WIDTH/2;
            var ey = yy*CELL_HEIGHT+CELL_HEIGHT/2;
            
       
            if(point_distance(ex, ey, obj_Player.x, obj_Player.y) &gt; 80 &amp;&amp; irandom(odds)==odds){
                     if(!mooseplaced){
                     instance_create(ex, ey, obj_moose);
                        mooseplaced = true;
        }
                instance_create(ex, ey, obj_snowman);
            }
        }
    }
}





 
//Place Tim Hortons.
 /*
nbrTries = 0;
do {
      xTemp = irandom_range((xx*CELL_WIDTH) - ((xx*CELL_WIDTH)/3), (xx*CELL_WIDTH));
      yTemp = irandom_range((yy*CELL_HEIGHT) - ((yy*CELL_HEIGHT)/3), (yy*CELL_HEIGHT));//@@bg_Tims.Width would be the best.
     nbrTries++;
     if  (nbrTries &gt; 100){
        break;
     }
} until (grid[# xTemp, yTemp] == FLOOR)
tile_add(bg_Tims, 0, 0, 128, 128, xTemp -128, yTemp -128 , -10)

*/










</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// destroy the grids
ds_grid_destroy(Level.grid);
//mp_grid_destroy(Level.path);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Restart the room
room_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
